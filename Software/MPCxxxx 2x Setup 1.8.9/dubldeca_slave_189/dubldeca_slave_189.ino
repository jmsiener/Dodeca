/*  Neutron Magpie Dodeca: 

A hodge podge of the original from Neutron Sound and 
Magpie Modular as well as the tweaks implemented by 
Steven Noreyko and with help from Paul Stoffregen's
tutorials and resources.  Also, shout out to 
Processaurus @ PJRC forums for his post and examples for 
implementing song position pointers.

I don't own an Octatrack (As 10/11/2018 at least!) but I do 
own an MPC1k and I needed an interface between my MPC and 
my modular.  What I needed was a bunch of drum trigs, 
something to keep my clocks in order, some 1v/oct voices, and 
whatever bonus bait I could slap on.  I ended up making a 
rather large departure from what Neutron/Magpie had done 
originaly.  I scrapped two indepedent trig channels because 
I don't care about it - all drum trigs are received on the 
drum channel for MIDI, channel 10.  1 voice is on Channel 9 and
another is on Channel 11.  I went for the high channels 
since if you ever chain your MIDI you might have a synth 
(MS-20 mini comes to mind) that's hard fixed to channel 1 in
which case you're SOL.  Easy enough to change that though.  
Nice thing about drum trigs on channel 10 is that all your drum 
trigs will play from one controller.  There's also a reset which 
goes high when your master starts playing in addition to the 
clock output. Also, there's an accent for each Dodeca module 
and you can change the accentVel variable to change the threshold.
All of this and I managed to keep 3 of the CC outs!

If anyone can figure out how to add a tempo sync'd LFO or 
envelope that is generated by the Teensy
(not eating up MIDI bandwidth) then holler at me.  I spent
too many hours thinking about that before I realized it was
pretty over my head.  Thanks though to Jim Matheson for trying
to point me in the right direction towards that envelope/LFO
idea, I'm just too dumb to get it right now.


Left Side Dodceca - DUBLDECA layout

0a.  Gate      1a.  1/VOct     
2a.  Vel       3a.  Reset    
4a.  Kick      5a.  LowAcc
6a.  Tom1      7a.  CC 73 
8a.  Tom2      9a.  CC 74 
10a. Tom3      11a. CC 75      

C - Kick
  C# - Snare
D - ClHat
  Eb - Clap
E - Tom 1
F - Tom 2
  F# - Open Hat
G - Tom 3
  Ab - Rim
A - Perc1
  Bb - Perc2
B  
 */

#include <MIDI.h>
MIDI_CREATE_DEFAULT_INSTANCE();

const uint8_t CHANA = 10;//set the MIDI channel here!
const uint8_t CHANB = 9;

uint8_t out2pin[] = {23, 0, 22, 25, 20, 6, 21, 5, 9, 4, 10, 3};//output number to actual teensy pin, dont change.
uint8_t whitekeys[] = {4, 0, 0, 0, 6, 8, 0, 10, 0, 0, 0, 0};//non zero keys sent to output number.
//                    {C, #, D, #, E, F, #, G , #, A, #, B}
uint8_t pulses;
uint8_t sixteenthnotes; 
uint8_t thirtysecondths;
uint8_t quartertoggle;
uint8_t wholetoggle;
bool playing;

uint8_t pitchoffset = 0;
uint8_t accentVel = 115;

byte CLOCK = 248; 
byte START = 250; 
byte CONTINUE = 251; 
byte STOP = 252; 
byte SPP = 242;     //song position pointer
byte currentSPP;
byte timeSig = 4;
byte currentSixteenthnotes;
//byte timeSigSubdiv = 4;

uint8_t cc2active[] = {73, 74, 75};
uint8_t cc2out[] = {7, 9, 11};

void setup() {
  // Initiate MIDI communications, listen to all channels

  for (int i = 0; i < 12; i ++) {
    if (out2pin[i]) {
      pinMode(out2pin[i], OUTPUT);
      analogWriteFrequency(out2pin[i], 200000);
    }
  }

  analogWriteResolution(7);
  
   for (int i = 0; i < 12; i ++) {//start up LED animation
    for (int j = 0; j < 128; j ++) {
      if (out2pin[i] == 0) analogWrite(A14, (j ));
      else analogWrite(out2pin[i], j );
      delay(1);
    }
    if (out2pin[i] == 0) analogWrite(A14, 0);
    analogWrite(out2pin[i], 0);
  }//end of start up animantion

  MIDI.begin(MIDI_CHANNEL_OMNI);
  // Connect the Handlers to the library, so it is called upon reception.
  MIDI.setHandleNoteOn(HandleNoteOn);  // Put only the name of the function
  MIDI.setHandleControlChange(HandleControlChange);
  MIDI.setHandleNoteOff(HandleNoteOff);
  MIDI.setHandleClock(HandleClock);
  MIDI.setHandleStart(HandleStart);
  MIDI.setHandleStop(HandleStop);
  MIDI.setHandleContinue(HandleContinue);
//  MIDI.setHandleSongPositionPointer(SongPosition);

  usbMIDI.setHandleNoteOn(HandleNoteOn);  // Put only the name of the function
  usbMIDI.setHandleNoteOff(HandleNoteOff);  
  usbMIDI.setHandleControlChange(HandleControlChange);
  
  usbMIDI.setHandleRealTimeSystem(RealTimeSystem);   


  Serial.begin(9600);
}

void loop() {
  // Call MIDI.read the fastest you can for real-time performance.
  MIDI.read();
  usbMIDI.read();

  // There is no need to check if there are messages incoming if they are bound to a Callback function.
}

void RealTimeSystem(byte realtimebyte) { 
  if(realtimebyte == CLOCK) { 
    HandleClock();
  } 
  if(realtimebyte == STOP) { 
    HandleStop();
  } 
  if(realtimebyte == START) { 
    HandleStart();
  }
  if(realtimebyte == CONTINUE) { 
    HandleContinue();
  }

} 
